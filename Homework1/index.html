<link href="prism.css" rel="stylesheet" />

<body>

<h1>
    Homework 1
<h1/>

<h2>
    Klemen Kotar / AMATH 342 with Eric Shea Brown
</h2>

<h1>
    Part A - MATLAB Tutorial Problems
</h1>

<h4>
    Exercise 4.1
</h4>

<p>
    INTEGRATOR STAGE 2: Write a code <b>integrator_2.m</b> which:
</p>    
<ul>
    <li>defines a signal <b>signal_vector</b> (a vector of signal values at different timepoints)</li>
    <li>defines a threshold <b>thresh</b></li>
</ul>
<p>
    and computes as its answer the first time that the cumulative sum of the signal crosses the threshold.
</p>
    
<pre><code class="language-matlab">
clear all;

t=[1:10];
signal_vector = sin(t);
thresh = 0.5;

for n = t;
    if (signal_vector(n) > thresh);
        disp("We are crossing the threshold at time t = : " + signal_vector(n))
        break
    end;
end;
</code></pre>
    
<h4>Exercise 3.2</h4>
    
<p>
    Imagine that you have a giant neural network, and each cell is either firing (“on”) or not (“off”). Each second, for every neuron that is already on, two more switch on. This is a model of EXCITATORY SYNAPTIC COMMUNICATION from the “on” neurons. At time <i>t = 0</i> seconds, 1 neuron is “on.” Write a program, called <b>neural_explosion.m</b> that does the following:
</p>
<ul>
    <li>using a for loop, compute a vector number_on that is the number of neurons on at each second, from <i>t = 0</i> to <i>t = 30</i> seconds.</li>
    <li>Make a plot of the number of neurons on vs. time. Label the axes “time” and “number on.” Hint: type <code class="language-matlab">help plot!</code></li>
</ul>

<pre><code class="language-matlab">
clear all;

number_on = [1];
for n = [1:30]
    number_on(n+1) = number_on(n) * 3;
end
disp(number_on)
t = [0:30];

plot(t, number_on, "-*")
title("number of neurons on vs. time");
xlabel("time");
ylabel("neurons on");
</code></pre>
    
<p>
    Executing the above program produces the following graph:
</p> 
    
<iframe src ="numberofneuronsonvs.time.html"></iframe>
    
<h4>
    Exercise 5.1
</h4>
<p>
    Write a function m-file <b>rmatrix.m</b> which takes as arguments 3 matrices A, S, Z, and returns the matrix B = A + S. ∗ Z.
</p>
    
<pre><code class="language-matlab">
function f=rmatrix(A, S, Z)
    U = S .* Z;
    f = A + U;
return;
</code></pre>
    
<h1>
    Part B - Spike Train Analysis and Tuning Curves
</h1>

<p>
    When I read though this exercise I decided to approach it partially <b>backwards</b>.
</p>
<p>
    The program <b>generate_noisy_data_cockroach.m</b> is producing simulations of measurments of spike trains. It produces a specified amount of trials to give us better accuracy. Our first task is to analyzie just a single output of the program as a raster plot. The trouble with this task is that we have to specify an angle at which we want to stimulate the cells to produce the spiketrain. Since we have no prior knowledge of wich angles are preffered by the cells, we have to blindly guess the angle for our initial analysis. Although this is closer to the prodedure we would ungergo if we were measuring novel data (i.e. data not generated by a computer), it can also lead to a rather dull analysis. To circumnavigate this I started by plotting the tuning curves for cells 1, 2 and 3 in order to identiy their prefered orientations, so I could analyze the individual spike trains at "interesting" positions.
</p>
    
<p>
    In order to achieve my goal I first decided to re-implement the program generate_noisy_data_cockroach.m as a function, of three arguments (stimDir, cell_num, ntrials).
</p>
<pre><code class="language-matlab"> 
% This is the generate_noisy_data_cockroach.m file modified to behave as a
% function instead of a human input script

% This code will generate a spiking response to an input based on a tuning
% curve and assuming (inhomogeneous) Poisson firing. The response adapts
% over time, with a time constant of tau

function spiketrain = noisy_data(stimDir, cell_num, ntrials)

    rand('state',sum(100*clock));

    nmsec = 300;    % number of milliseconds to record for
    times= 1:nmsec; % vector of time points (1 msec apart)

    spiketrain = zeros(ntrials,nmsec);      % set up output data

    rate = cockroach_tuning(stimDir, cell_num); %returns rate, in Hz.       
    tau = 100;      % adaptation time constant in msec
    delta_t=0.001; %time bin, in seconds (1 msec)
    ratefun = rate*exp(-times/tau);  % adapting rate function 



    for j = 1:ntrials

        for i = 1:nmsec

                spiketrain(j,i) = round(rand + ratefun(i)*delta_t -1/2 );

        end

    end
    
return
</code></pre>
    
<p>
    The <b>noisy_data()</b> methode can now be used in a loop, instead of manually generating matrices for each data point (stimulus direction).
</p>
<p>
    Next I needed a way to obtain the trial averaged spike count rate from the spiketrain vectors. I created a simple helper methode <b>trial_averaged_spike_count_rate()</b> that sums up the action potentials in each spike train returned by <b>noisy_data()</b> and normalizes them with the duration of each trial, in effect returning a matrix of 1 column containing the trial averaged spike count rate for each trial.
</p>
<pre><code class="language-matlab">
function f = trial_averaged_spike_count_rate(x)
    m = sum(x,2); % Sum up the action potentials in each spike train
    f = m/0.3; % Normalize by trial duration of 300 ms
return;
</code></pre>
    
<p>
    Finally I wanted to compute the average firing rate at every angle, so I wrote anothe helper methode <b>average_firing_rate()</b> that takes a matrix returned by <b>noisy_data()</b>, runs it through <b>trial_averaged_spike_count_rate(x)</b> and then takes the mean of that vector to return the average firing rate for a specific cell at a specific angle of stimulus.
</p>
<pre><code class="language-matlab">
function f = average_firing_rate(x)
    % Take the mean trial averaged spike count rate over every trial
    f = mean(trial_averaged_spike_count_rate(x));
return
</code></pre>

<p>
    Using the above described methodes I am able to generate a plot of the average firing rates for all 3 cells for stimulus orientations between 0 and 90 degrees using the following code:
</p>
    
<pre><code class="language-matlab">
clear all

% Pre-allocate memory for arrays to increase efficiency
average_spike_rate1 = zeros(1, 90);
average_spike_rate2 = zeros(1, 90);
average_spike_rate3 = zeros(1, 90);

% Measure spiketrains for cells 1-3 at every integer angle between 0 and 90
% degrees, with 100 trials per sample
for angle = [1:90]
    % Average out the frequency amongst all of the trials
    average_spike_rate1(angle) = average_firing_rate(noisy_data(angle, 1, 100));
    average_spike_rate2(angle) = average_firing_rate(noisy_data(angle, 2, 100));
    average_spike_rate3(angle) = average_firing_rate(noisy_data(angle, 3, 100));
end

% Define theta as the set of all integer angles between 1 and 90 degrees
% and use it to plot the average spike rate per angle for each trial
theta = [1:90];


% Find the the preffered orientations of each cell (the Max values on the
% graph)
max1 = [find(average_spike_rate1 == max(average_spike_rate1)) max(average_spike_rate1)]
max2 = [find(average_spike_rate2 == max(average_spike_rate2)) max(average_spike_rate2)]
max3 = [find(average_spike_rate3 == max(average_spike_rate3)) max(average_spike_rate3)]

% Plot the tuning curve for each of the trials on the same plot
plot(theta, average_spike_rate1, theta, average_spike_rate2, theta, average_spike_rate3)
title("Tuning Curves of Cells 1, 2, 3 in response to Stimulus Directions from 1 to 90 Degrees");
legend("Cell 1", "Cell 2", "Cell 3");
xlabel("Stimulus Direction Angle [Degrees]");
ylabel("Trial Averaged Firing Rate [Action Potentials / Second]");
text(max1(1), max1(2)*0.95, "Prefered Position of Cell 1");
text(max2(1), max2(2)*0.99, "Prefered Position of Cell 2");
text(max3(1)*0.5, max3(2), "Prefered Position of Cell 3");

% Convert the plot to plotly figure for nice html display
fig2plotly(gcf, 'offline', true);
</code></pre>

<p>
    Executing the above script yields a graph looking something like this:
</p>
    
<iframe src ="TuningCurvesofCells1,2,3inresponsetoStimulusDirectionsfrom1to90Degrees.html"></iframe>

<p>
    We can clearly see that each cell has a distinct prefered stimulus orientation at which it's average firing rate peaks. All of these points are marked on the graph, with the exception of cell 3, which has 2 preffered positions (at roughly 30 degrees and 60 degrees).
<p/>
<p>
    Cell 1 and 2 interestingly have the same preffered position, however the tuning curve of Cell 1 is sharper, indicating that it is tuned more finely to respond to stimulus applied at 45 degrees.
</p>
<p>
    After analyzing the graph we can determine that it would be interesting to examine the raster plots of spike trains over multiple trials for the following cells and angles:
</p>
<ul>
    <li><b>Cell 1:</b> 39 degrees, 45 degrees</li>
    <li><b>Cell 2:</b> 33 degrees, 45 degrees</li>
    <li><b>Cell 3:</b> 30 degrees, 60 degrees</li>
</ul>
    
<h3>Spike Train Analysis</h3>
    
<p>
    In order to make this analysis easier, I wrote a script that takes (stimDir, cell_num, ntrials) as arguments and preduces a raster plot of several trials of spike trains. The color changing code is there to make all of the 0 values (the times the neuron is not firing) white. This way the action potentials themselves stand out more. The function also outputs the mean firing rate and standard deviation between the trials.
</p>
    
<pre><code class="language-matlab">
% Function that produces a raster plot of several trials of spiketrains produced by a cell when applied a stimulus at a certain angle
% The function also outputs the mean firing freqnecy and standard deviation between the trials
clar all
function f = spike_train_analizer(stimDir, cell_num, ntrials)
    data = noisy_data(stimDir, cell_num, ntrials);
         
     myColorMap = jet(256);
     myColorMap(1,:) = 1;
     colormap(myColorMap);
     colorbar
     
     imagesc(data)
     title("Cell " + cell_num + " - " + stimDir + " degrees Spike Train Plot");
     xlabel("Time [ms]");
     ylabel("Trial Number");

    Average_firing_rate = average_firing_rate(data)
    Standard_deviation = std(trial_averaged_spike_count_rate(data))
end
</code></pre>
    
<h3>Cell 1 - 39 degrees</h3>

<img src="Cell1-39Deg.png">
<p><b>Average Firing Rate = 47.4333, Standard Deviation = 13.5575</b></p>
<p>
    Here we can see the spike trains produced by a cell firing at about 50% of its peak rate. As expected we do not see a strong repeatability of action potentials at exact times from trial to trial, but there is a clear left bias in the chart. This means that during the duration of our sample, the firing rate first rapidly goes up, and the slowly dies down. This inconsistency is attributed to neural adaption to the stimulus.
</p>
<br>
<br>
    
<h3>Cell 1 - 45 degrees</h3>

<img src="Cell1-45Deg.png">
<p><b>Average Firing Rate =  91.6667, Standard Deviation =  11.9928</b></p>
<p>
    Here we can see that the cell is clearly more active. Interestingly the left side of the graph, near <i>t = 0</i> has seen a disproportionate increase in action potentials. This suggests that the cell is most active for the first 150ms after the stimulus is presented, while the last 150ms seem cloaser to noise.
</p>
<br>
<br>

<h3>Cell 2 - 33 degrees</h3>
    
<img src="Cell2-33Deg.png">
<p><b>Average Firing Rate = 45.7000, Standard Deviation = 11.5499</b></p>
<p>
    This graph looks remarkably simmilar to that of <b>Cell 1 - 39 Degrees</b>. This angle of stimulus was chosen specifically because it seems to stimulate a firing rate simmilar to that of cell 1 while stimulated at 39 degrees. Clearly the two cells exhibit a very simmilar spike train pattern when firing at a simmilar frequency. 
<br>
<br>
    
<h3>Cell 2 - 45 degrees</h3>

<img src="Cell2-45Deg.png">
<p><b>Average Firing Rate = 92.8000, Standard Deviation = 17.1788</b></p>
<p>
    Again we see a strong corellation between this graph at the graph of cell 1 being excited at a simmilar frequency. Perhaps this is a limitation of the program simulating our outpu, or perhaps it is a trend in nature that cells firing at a simmilar frequency will exhibit a simmilar pattern of very rapid firing near <i>t = o</i>, which slowly tapers down.
</p>
<br>
<br>
    
 
<h3>Cell 3 - 30 degrees</h3>
    
<img src="Cell3-30Deg.png">
<p><b>Average Firing Rate = 97.7333, Standard Deviation = 16.0728</b></p>
<p>
    This graph looks very simmilar to other graphs of cells firing at thier peak rate. Again we see a heavy firing bias towards times cloaser to <i>t = 0</i>. 
</p>
<br>
<br>

<h3>Cell 3 - 60 degrees</h3>
    
<img src="Cell3-60Deg.png">
<p><b>Average Firing Rate = 96.2333, Standard Deviation = 14.5540</b></p>
<p>
    Somewhat not suprisingly there seems to be no major difference between the spiketrains that appear at the firs peak of the tuning curve, and the spiketrains that appear at the second peak. We seem to be encoutering a generic firing frequency signiture.
</p>
<br>
<br>
    
<h3>Neural Adaptation to Stimuli</h3> 

<p>
    As noted in many of the spiketrain analysis, there seems to be a clear trend of a firing bias towards times closer to <i>t=0</i>. This seems to be a clear example of Neural Adaptation to the Stimulus. It suggests that perhaps neural cells are wired towards detecting a <b>change in stimulus towards a prefered direction</b>, rather then an absolute stimulus in a preffered direction.
</p>
    
<p>
    Bellow is a graph of the average values amongst all samples of the binary state of the neuron (i.e. either firing or not firing) for every bucket of time recorded during the smaple. 
</p>
<p>
    The graph was produced by the function <b>neural_adaptation_plot()</b>, taking (stimDir,cell_num, ntrials) as arguments and producing a raster plot as the result.
</p>

<pre><code class="language-matlab">
% Function that creates a graph of the average values amongst all samples
% of the binary state of the neuron (i.e. either firing or not firing) for 
% every bucket of time recorded during the smaple taking (stimDir,
% cell_num, ntrials) as arguments.


function f = neural_adaptation_plot(stimDir, cell_num, ntrials)

    data = noisy_data(stimDir, cell_num, ntrials);
    y = mean(data);
    x = [1:300];

    plot(x,y)

    title("Average Firing rate vs. Time Elapse in Sample Collection");
    xlabel("Time Elapsed in Sample Collection [milliseconds]");
    ylabel("Probability that neuron fires in this time bucket");

    % Convert the plot to plotly figure for nice html display
    fig2plotly(gcf, 'offline', true);
    
return
</code></pre>

<iframe src ="AverageFiringratevs.TimeElapseinSampleCollection.html"></iframe>
    
<p>
    The above graph specifically is of Cell 1 Stimulated under 45 Degrees, but the other cells produce very simmilar graphs, when firing at max rate. Although there is a great deal of local variability in the data we can see a clear non-linear trend. This confirms our ealrier assumptions of an early fire bias.
</p>

<h2>Tuning Curves (Finally!)</h2> 
    
<p>
    We have already examined a superimposed graph of the three tuning curves in the first figure of this analysis. Now let us look at examine the tuning curves individually, along with thier standard deviations.
</p>
    
<p>
    We will be using a slightly modified version of the script used to produce the original graph called <b>individual_responses()</b>. I re-inplemented the program as a function to allow me to easily switch between graphing for cell 1, 2 and 3.
</p>
    
<pre><code class="language-matlab">
function f = individual_responses(cell_number)
    % Pre-allocate memory for arrays to increase efficiency
    average_spike_rate = zeros(1, 90);
    STD = zeros(1, 90);

    % Measure spiketrains for cells 1-3 at every integer angle between 0 and 90
    % degrees, with 100 trials per sample
    for angle = [1:90]
        % Average out the frequency amongst all of the trials
        data = noisy_data(angle, cell_number, 100);
        average_spike_rate(angle) = average_firing_rate(data);
        % Compute vstandard deviation at every stimulus value
        STD(angle) = std(trial_averaged_spike_count_rate(data));
    end

    % Define theta as the set of all integer angles between 1 and 90 degrees
    % and use it to plot the average spike rate per angle for each trial
    theta = [1:90];

    % Plot the tuning curve for the cell and the standard deviation bars
    plot(theta, average_spike_rate, theta, average_spike_rate + STD, "--b", theta, average_spike_rate - STD, "--b")
    title("Tuning Curves of Cells "+ cell_number + " With STD Error Bounds in Response to Stimulus Directions from 1 to 90 Degrees");
    xlabel("Stimulus Direction Angle [Degrees]");
    ylabel("Trial Averaged Firing Rate [Action Potentials / Second]");

    % Convert the plot to plotly figure for nice html display
    fig2plotly(gcf, 'offline', true);
return
</code></pre>
    
<h3>Cell 1</h3>
    
<iframe src ="Tuning%20Curves%20of%20Cell%201%20With%20STD%20Error%20Bounds%20in%20Response%20to%20Stimulus%20Directions%20from%201%20to%2090%20Degrees.html"></iframe>
    
<p>
  Cell 1 and Cell 2 achieve their maximum firing frequency at a nearly identical stimulus angle. This poses several interesting questions biological questions. Why did 2 neurons evolve to convey the same signal? Why does this occure at 45 degrees?
</p>
<p>
    Perhaps some form of awnsers to those quesitons lie in a further analysis of the graph. Cell 1 has a much narrower preffered orientation region, and therfore a much steeper firing rate curve. <b>Perhaps 45 degrees is a very critical angle for a cricket, and as the stimulus slowly approaches this angle it first triggers Cell 2 as a perliminary signal and then Cell 1 as a critical signal.</b>
</p>
<p>
    The angle of 45 degree is itself fascinating. Besides being a nice angle on our "abstract man-made" idea of the unit circle it also represents a much more fundamental phsycial truth. It is the angle at which a force distributes most favorabely along 2 directional components. This is true because <i>sin(x) = cos(x) if x = 45 degrees</i>. This magical angle appears in many places throughout nature and engineering. For example firing a shell from a cannon at 45 degrees is classicaly considered the ideal configuration for max range, because of that favorable force distribution along the x and y axis. Perhas the cricket is in fear of braking off part of the body at this angle and its neurons are telling it to escape, or conversely maybe ne cricket is trying to apply max force to some obejct. In any case it is fascinating to obeserve a corelation between the evolution driven nervous systems of animals and elementary phsyics.
</p>
<br><br>
    
<h3>Cell 2</h3>    

<iframe src ="Tuning%20Curves%20of%20Cells%202%20With%20STD%20Error%20Bounds%20in%20Response%20to%20Stimulus%20Directions%20from%201%20to%2090%20Degrees.html"></iframe>
<p>
    The analysis of Cell 1 provided a possible hypothesis as to why Cell 1 and 2 have a simmilar max firing rate angle. For cell 2 Let's focus on the standard deviation curves.
</p>
<p>
    Quickly one notices a correlation between average firing rate and standard deviation. Quite intuatively, it seems that the larger the firing rate the larger the standard deviation. This also means that the slimmer and sharper plot of Cell 1 has less variability in its data than the wider and more gradually sloping plot of Cell 2. 
</p>
<p>
    Interestingly it seems that <b>the wider the range of partially prefered stimulus orientation, the less accurate our measurement is.</b> This is because cell actuations inherently introduce some noise into our data. The larger the range of cell firing activity the more noise we will get in our data set and the less accurate our final result will be.
</p>
<br><br>
    
<h3>Cell 3</h3>
    

<iframe src ="Tuning%20Curves%20of%20Cells%203%20With%20STD%20Error%20Bounds%20in%20Response%20to%20Stimulus%20Directions%20from%201%20to%2090%20Degrees.html"></iframe>
    
<p>
    Cell 3 is perhaps the most interesting one of all. It is also the one with lest reliable data. Although there is quite a range of standard deviation in in the middle of the graph, it seems safe to assume that there is a distinct local minima between the two peaks.
</p>
<p>
    The two peeks seem to conincide with two more "famous" angles - 30 degrees and 60 degrees. What gives? Do Crickets know geometry?
</p>
<p>
     This could be an artifact of our artificially generated data, but perhaps it is not that crickets know gemometry, but that 30 and 60 degrees are fundamental angles that have meaning beyond just mathematics. Because of the way they distribute forces they are often used as in bridge and building trusses. Maybe the cricket has a similar need for force distribution.
</p>    
<p>
    Another option is that this acts as another early warning sign that we are approaching that critical 45 degree angle. 
</p>
<p>
    Based on the analysis of spiketrain raster plots we can tell that the cricket has no way of differentiating between these two angles from this single neuronal input alone. Perhaps this neuron works with many other, and some short term memory inside the crickets berain to functionas an encoder of sorts - determining current position based on previous position data not just current input alone.
</p>
    
<h2>Conclusion</h2>
    
<p>
    This was one of the hardest and longest homeworks I have ever done. At the same time, it was by far the most fun I ever had doing homework. The freedom to take this project any way we saw fint, and the abondance of secrets contained in this rich data set provided so many pathways for my mind to wonder down. I ultimately did not end up pursuing all of them, but I am very happy about the finished product I presented. 
</p>
<p>
    (I typed this very fast in a code editor without spellcheck, so I would like to aplogize for any inadvertent spelling errors).
</p> 
    
<p>
    All in all this was very fun and educational, and I can not wait for the enxt project!
</p> 
<body/>


<style>

body {
	margin-left: 20%;
	margin-right: 20%;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    font-size: 14px;
    line-height: 1.5;
    color: #24292e;
    background-color: #fff
}
    
img {
    width: 100%;    
}

h1 {
    font-size: 350%;    
}
    
h2 {
    color: rgb(53, 140, 203);
}
iframe {
    width: 90%;
    height: 90%;
    border: none;
}

</style>

<script src="prism.js"></script>
